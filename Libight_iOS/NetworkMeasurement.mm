// Part of MeasurementKit <https://measurement-kit.github.io/>.
// MeasurementKit is free software. See AUTHORS and LICENSE for more
// information on the copying conditions.

#import "NetworkMeasurement.h"

#import "measurement_kit/common.hpp"

#include <arpa/inet.h>
#include <ifaddrs.h>
#include <resolv.h>
#include <dns.h>

static NSArray *getDeviceDNS()
{
    NSMutableArray *addresses = [[NSMutableArray alloc] init];
    
    res_state res = (res_state)malloc(sizeof(struct __res_state));
    
    int result = res_ninit(res);
    
    if ( result == 0 )
    {
        for ( int i = 0; i < res->nscount; i++ )
        {
            NSString *s = [NSString stringWithUTF8String :  inet_ntoa(res->nsaddr_list[i].sin_addr)];
            NSLog(@"dns %@",s);
            [addresses addObject:s];
        }
    }
    return addresses;
}

// Make sure that logging messages not bound to any specific test (mainly
// messages generated by the async thread) end up to stderr via NSLog()
static void init_async_logger() {
    static bool initialized = false;
    if (!initialized) {
        mk::set_verbose(1);
        // XXX Ok to call NSLog() from another thread?
        mk::on_log([](const char *s) {
            //NSLog(@"%s", s);
        });
        
        //This if must exists because the simulator is also considered a TARGET_OS_IPHONE
        #if TARGET_IPHONE_SIMULATOR
            NSString *hello = @"Hello, iPhone simulator!";
            NSLog(@"%@", hello);
        #elif TARGET_OS_IPHONE
            NSString *hello = @"Hello, device!";
            NSLog(@"%@", hello);
            NSArray *dnsServers = getDeviceDNS();
            if ([dnsServers count] > 0) {
                evdns_base *ns = mk::get_global_evdns_base();
                if (evdns_base_nameserver_ip_add(ns, [[dnsServers objectAtIndex:0] UTF8String])){
                    throw std::runtime_error("Cannot set server address");
                }
            }
        #else
            NSString *hello = @"Hello, unknown target!";
            NSLog(@"%@", hello);
        #endif

        initialized = true;
    }
}

// Access static async instance. Currently there is a static instance to
// guarantee that such instance has the same lifecycle of the App
static mk::Async& get_async() {
    static mk::Async async;
    init_async_logger();
    return async;
}


@implementation NetworkMeasurement

-(id) init {
    self = [super init];
    self.logLines = [[NSMutableArray alloc] init];
    self.finished = FALSE;
    return self;
}

-(void) run {
    // Nothing to do here
}

-(NSString*) getDate{
    NSDateFormatter *dateformatter=[[NSDateFormatter alloc]init];
    [dateformatter setDateFormat:@"dd-MM-yyyy HH:mm:ss"];
    return [dateformatter stringFromDate:[NSDate date]];
}


@end


@implementation DNSInjection : NetworkMeasurement

-(id) init {
    self = [super init];
    self.name = @"dns_injection";
    return self;
}

- (void) run {
    NSBundle *bundle = [NSBundle mainBundle];
    NSString *path = [bundle pathForResource:@"hosts" ofType:@"txt"];
    mk::ooni::DnsInjectionTest()
        .set_backend("8.8.8.8:53")
        .set_input_file_path([path UTF8String])
        .set_verbose()
        .on_log([self](const char *s) {
            NSString *current = [NSString stringWithFormat:@"%@: %@", [super getDate], [NSString stringWithUTF8String:s]];
            NSLog(@"%s", s);
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.logLines addObject:current];
            });
        })
        .run([self]() {
            NSLog(@"dns_injection testEnded");
            dispatch_async(dispatch_get_main_queue(), ^{
                self.finished = TRUE;
                [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshTable" object:nil];
            });
        });
}


@end

@implementation HTTPInvalidRequestLine : NetworkMeasurement

-(id) init {
    self = [super init];
    self.name = @"http_invalid_request_line";
    return self;
}

-(void) run {
    mk::ooni::HttpInvalidRequestLineTest()
    .set_backend("http://www.google.com/")
    .set_verbose()
    .on_log([self](const char *s) {
        // XXX OK to send messages to object from another thread?
        NSString *current = [NSString stringWithFormat:@"%@: %@", [super getDate],
                             [NSString stringWithUTF8String:s]];
        NSLog(@"%s", s);
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.logLines addObject:current];
        });
    })
    .run([self]() {
        NSLog(@"http_invalid_request_line testEnded");
        dispatch_async(dispatch_get_main_queue(), ^{
            self.finished = TRUE;
            [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshTable" object:nil];
        });
    });
}

@end

@implementation TCPConnect : NetworkMeasurement

-(id) init {
    self = [super init];
    self.name = @"tcp_connect";
    return self;
}

-(void) run {
    NSBundle *bundle = [NSBundle mainBundle];
    NSString *path = [bundle pathForResource:@"hosts" ofType:@"txt"];

    mk::ooni::TcpConnectTest()
    .set_port("80")
    .set_input_file_path([path UTF8String])
    .set_verbose()
    .on_log([self](const char *s) {
        NSString *current = [NSString stringWithFormat:@"%@: %@", [super getDate],
                             [NSString stringWithUTF8String:s]];
        NSLog(@"%s", s);
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.logLines addObject:current];
        });
    })
    .run([self]() {
        NSLog(@"tcp_connect testEnded");
        dispatch_async(dispatch_get_main_queue(), ^{
            self.finished = TRUE;
            [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshTable" object:nil];
        });
    });
}

@end